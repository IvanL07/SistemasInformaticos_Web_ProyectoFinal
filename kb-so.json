[
  {"id":"so-kernel","tags":["so","kernel","núcleo"],"patterns":["kernel","núcleo","que es el kernel","qué es el kernel"],"short":"Kernel = núcleo del SO: CPU, memoria, E/S, seguridad.","answer":"**Kernel (núcleo)**\n\nEl **kernel** es la parte central del sistema operativo. Gestiona:\n- **CPU**: planificación (scheduler)\n- **Memoria**: RAM y memoria virtual\n- **E/S**: drivers, disco, red\n- **Seguridad**: permisos/aislamiento\n\nEjemplos: Linux kernel, Windows NT, XNU (macOS)."},
  {"id":"so-user-kernel-space","tags":["so","modo usuario","modo kernel","privilegios"],"patterns":["modo usuario","modo kernel","user space","kernel space"],"short":"Apps en modo usuario; kernel/drivers en modo kernel.","answer":"**Modo usuario vs modo kernel**\n\n- **Modo usuario**: apps normales (privilegios limitados).\n- **Modo kernel**: kernel y drivers (máximos privilegios).\n\nLas apps piden servicios mediante **syscalls**, lo que mejora seguridad y estabilidad."},
  {"id":"so-syscalls","tags":["so","syscall","llamada al sistema"],"patterns":["syscall","llamada al sistema","system call"],"short":"Puerta de entrada al kernel: open/read/write/crear proceso.","answer":"**Syscalls**\n\nSon llamadas que permiten a un programa solicitar servicios al kernel (abrir archivos, crear procesos, red…)."},
  {"id":"so-proceso","tags":["so","procesos","process"],"patterns":["proceso","procesos","process","programa en ejecución"],"short":"Proceso = programa ejecutándose + memoria/recursos + hilos.","answer":"**Proceso**\n\nUn proceso es un programa en ejecución con su propio espacio de memoria, recursos (archivos, sockets) y al menos un hilo."},
  {"id":"so-hilo","tags":["so","hilos","threads","concurrencia"],"patterns":["hilo","hilos","thread","threads"],"short":"Hilo = ejecución dentro del proceso (comparten memoria).","answer":"**Hilos (threads)**\n\nLos hilos comparten memoria del proceso. Ventaja: concurrencia/paralelismo. Riesgo: condiciones de carrera si no sincronizas."},
  {"id":"so-context-switch","tags":["so","cambio de contexto","context switch"],"patterns":["context switch","cambio de contexto"],"short":"Guardar/restaurar estado al cambiar de proceso/hilo (coste).","answer":"**Cambio de contexto**\n\nEs el coste de cambiar la CPU de un hilo/proceso a otro: guardar registros/estado y cargar los del siguiente."},
  {"id":"so-scheduler","tags":["so","scheduler","planificador","quantum"],"patterns":["scheduler","planificador","quantum","prioridad"],"short":"Decide qué corre y cuándo (prioridades/quantum).","answer":"**Scheduler (planificador)**\n\nDecide qué proceso/hilo usa la CPU. Conceptos: **prioridades**, **quantum**, estados (ready/running/waiting)."},
  {"id":"so-memoria-virtual","tags":["so","memoria virtual","paginación","swap"],"patterns":["memoria virtual","paginación","paging","swap","pagefile"],"short":"Mapea memoria por páginas; puede usar disco si falta RAM.","answer":"**Memoria virtual**\n\nCada proceso “cree” tener memoria propia grande. Se divide en **páginas**; si falta RAM, se usa disco (swap/pagefile) y baja el rendimiento."},
  {"id":"so-pagefault","tags":["so","page fault","fallo de página"],"patterns":["page fault","fallo de pagina","fallo de página"],"short":"Acceso a página no cargada → el SO la trae (puede ser lento).","answer":"**Page fault (fallo de página)**\n\nOcurre cuando un proceso accede a una página no presente en RAM. El SO debe cargarla (posible lectura de disco)."},
  {"id":"so-deadlock","tags":["so","deadlock","interbloqueo"],"patterns":["deadlock","interbloqueo"],"short":"Bloqueo circular por recursos; se previene/evita/detecta.","answer":"**Deadlock (interbloqueo)**\n\nSituación donde procesos/hilos quedan bloqueados esperando recursos entre sí. Se gestiona con prevención, evitación o detección/recuperación."},
  {"id":"so-sync","tags":["so","sincronización","mutex","semaforo"],"patterns":["mutex","semaforo","semáforo","lock","race condition"],"short":"Evita carreras con mutex/semáforos/locks.","answer":"**Sincronización**\n\nPara evitar **race conditions** se usan mecanismos como **mutex**, **semáforos**, locks y regiones críticas."},
  {"id":"so-fs","tags":["so","sistema de archivos","filesystem","ntfs","ext4"],"patterns":["filesystem","sistema de archivos","ntfs","ext4","fat32","exfat"],"short":"Cómo se organizan archivos/permisos/metadatos.","answer":"**Sistema de archivos**\n\nDefine cómo se guardan datos y metadatos. Windows: NTFS. Linux: ext4/xfs/btrfs. Conceptos: permisos, journaling, rutas."},
  {"id":"so-permisos","tags":["so","permisos","usuarios","grupos","acl"],"patterns":["permisos","usuarios","grupos","acl","chmod","chown"],"short":"Linux rwx; Windows ACLs más granulares.","answer":"**Permisos**\n\nLinux: rwx (dueño/grupo/otros). Windows NTFS: ACLs. Buen principio: **mínimos privilegios**."},
  {"id":"so-boot","tags":["so","arranque","boot","uefi","bios"],"patterns":["boot","arranque","uefi","bios","grub","bootloader"],"short":"BIOS/UEFI → bootloader → kernel → servicios → login.","answer":"**Arranque**\n\nSecuencia típica: BIOS/UEFI → bootloader → kernel → init/services → login → escritorio."},
  {"id":"so-io","tags":["so","entrada salida","io","drivers"],"patterns":["entrada salida","e/s","io","drivers","controladores"],"short":"Drivers conectan SO con hardware; buffers/cachés optimizan.","answer":"**E/S y drivers**\n\nLos drivers traducen peticiones del SO a hardware. Se usan buffers/cachés para rendimiento."},
  {"id":"so-cache","tags":["so","cache","caché","buffer"],"patterns":["cache","caché","buffer","buffering"],"short":"Caché acelera; coherencia/flush importan.","answer":"**Caché / buffering**\n\nSe guarda información temporalmente (RAM) para acelerar. Importante: coherencia y volcado (flush)."},
  {"id":"so-virtualizacion","tags":["so","virtualización","hypervisor","vm"],"patterns":["virtualizacion","virtualización","hypervisor","maquina virtual","vm"],"short":"Hypervisor ejecuta VMs aisladas; tipo 1 vs tipo 2.","answer":"**Virtualización**\n\nUn **hypervisor** permite ejecutar máquinas virtuales aisladas. Tipo 1 (bare-metal) y tipo 2 (sobre un SO)."},
  {"id":"so-contenedores","tags":["so","contenedores","docker","namespaces","cgroups"],"patterns":["contenedor","contenedores","docker","namespaces","cgroups"],"short":"Aislamiento a nivel SO (más ligero que VM).","answer":"**Contenedores**\n\nAíslan procesos usando mecanismos del SO (Linux: namespaces/cgroups). Más ligeros que VMs."},
  {"id":"so-cli-gui","tags":["so","cli","gui","terminal"],"patterns":["cli","gui","terminal","interfaz gráfica"],"short":"CLI = comandos; GUI = ventanas; ambos complementarios.","answer":"**CLI vs GUI**\n\nCLI: eficiente, automatizable. GUI: accesible/visual. Lo pro es dominar ambos."}
]
